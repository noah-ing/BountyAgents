/**
 * Exploit Forge
 *
 * Where validated vulnerabilities become working exploits.
 * Three Smiths craft PoCs in parallel, then the Forge Master combines them.
 *
 * Success threshold: 0.1+ native tokens profit on forked chain.
 */

import { createAgent, DynamicAgent, AgentTemplates } from '../base-agent.js';
import type {
  VulnerabilityFinding,
  PopeSynthesis,
  ForgedExploit,
  ExploitApproach,
  ContractInfo,
} from '../../types/index.js';

// ============================================================================
// Types
// ============================================================================

export interface ForgeConfig {
  profitThreshold: number; // In native tokens (default 0.1)
  maxIterations: number;
  parallelApproaches: boolean;
}

// ============================================================================
// Exploit Forge
// ============================================================================

export class ExploitForge {
  private config: ForgeConfig;
  private directSmith: DynamicAgent;
  private flashLoanSmith: DynamicAgent;
  private chainedSmith: DynamicAgent;
  private forgeMaster: DynamicAgent;

  constructor(config?: Partial<ForgeConfig>) {
    this.config = {
      profitThreshold: config?.profitThreshold ?? 0.1,
      maxIterations: config?.maxIterations ?? 5,
      parallelApproaches: config?.parallelApproaches ?? true,
    };

    // Create the smiths
    this.directSmith = createAgent(AgentTemplates.exploitSmith('direct'));
    this.flashLoanSmith = createAgent(AgentTemplates.exploitSmith('flash-loan'));
    this.chainedSmith = createAgent(AgentTemplates.exploitSmith('chained'));
    this.forgeMaster = createAgent(AgentTemplates.forgeMaster());

    console.log('[Forge] Initialized with 3 Smiths + Forge Master');
  }

  /**
   * Forge exploits for all validated vulnerabilities
   */
  async forge(
    synthesis: PopeSynthesis,
    contracts: ContractInfo[]
  ): Promise<ForgedExploit[]> {
    const exploits: ForgedExploit[] = [];
    const validatedFindings = synthesis.validatedVulnerabilities;

    console.log(`[Forge] Forging exploits for ${validatedFindings.length} vulnerabilities`);

    for (const finding of validatedFindings) {
      console.log(`[Forge] Forging: ${finding.title}`);

      try {
        const exploit = await this.forgeSingle(finding, synthesis, contracts);
        exploits.push(exploit);
      } catch (error) {
        console.error(`[Forge] Failed to forge ${finding.title}:`, error);
      }
    }

    return exploits;
  }

  /**
   * Forge a single exploit
   */
  private async forgeSingle(
    finding: VulnerabilityFinding,
    synthesis: PopeSynthesis,
    contracts: ContractInfo[]
  ): Promise<ForgedExploit> {
    const context = this.buildExploitContext(finding, synthesis, contracts);

    // Run all three approaches in parallel
    console.log('[Forge] Running 3 approaches in parallel...');

    const approaches = await Promise.all([
      this.runSmith(this.directSmith, 'direct', context),
      this.runSmith(this.flashLoanSmith, 'flash-loan', context),
      this.runSmith(this.chainedSmith, 'chained', context),
    ]);

    console.log('[Forge] Combining approaches with Forge Master...');

    // Forge Master combines them
    const finalExploit = await this.combine(approaches, context);

    return {
      id: `exploit-${finding.id}`,
      vulnerability: finding,
      approaches,
      finalExploit,
      testResults: [], // Will be populated when run on forked chain
      verified: false,
      profitAchieved: 0,
    };
  }

  /**
   * Run a single smith's approach
   */
  private async runSmith(
    smith: DynamicAgent,
    strategy: ExploitApproach['strategy'],
    context: string
  ): Promise<ExploitApproach> {
    const smithInfo = smith.getInfo();

    const prompt = `${context}

Write a complete Foundry test that exploits this vulnerability using the ${strategy} approach.

Requirements:
1. Must be a complete, compilable Foundry test
2. Must inherit from ExploitBase or FlashLoanBase
3. Must include clear comments explaining each step
4. Must log profits and state changes
5. Must aim for ${this.config.profitThreshold}+ ETH profit

Output ONLY the Solidity code, no explanations.`;

    const response = await smith.analyze(prompt);

    // Extract code from response
    let code = response.content;
    const codeMatch = code.match(/```solidity\s*([\s\S]*?)```/);
    if (codeMatch) {
      code = codeMatch[1].trim();
    }

    return {
      name: smithInfo.name,
      strategy,
      description: `${strategy} exploit approach`,
      code,
      estimatedProfit: 0, // Will be calculated after testing
      capitalRequired: strategy === 'flash-loan' ? 0 : 1, // Flash loans need 0 capital
      successProbability: 0,
    };
  }

  /**
   * Combine approaches with Forge Master
   */
  private async combine(approaches: ExploitApproach[], context: string): Promise<string> {
    const prompt = `You are the Forge Master. Combine these exploit approaches into the optimal final exploit.

${context}

=== DIRECT APPROACH ===
${approaches[0].code}

=== FLASH LOAN APPROACH ===
${approaches[1].code}

=== CHAINED APPROACH ===
${approaches[2].code}

Your task:
1. Analyze each approach for strengths and weaknesses
2. Combine the best elements of each
3. Optimize for maximum profit
4. Ensure the exploit is reproducible across multiple blocks

Output ONLY the final Solidity code, no explanations.`;

    const response = await this.forgeMaster.analyze(prompt);

    // Extract code from response
    let code = response.content;
    const codeMatch = code.match(/```solidity\s*([\s\S]*?)```/);
    if (codeMatch) {
      code = codeMatch[1].trim();
    }

    return code;
  }

  /**
   * Build context for exploit development
   */
  private buildExploitContext(
    finding: VulnerabilityFinding,
    synthesis: PopeSynthesis,
    contracts: ContractInfo[]
  ): string {
    const contractCode = contracts
      .map((c) => `// ${c.name} (${c.address} on ${c.chain})\n${c.sourceCode}`)
      .join('\n\n// ---\n\n');

    return `=== VULNERABILITY ===
${JSON.stringify(finding, null, 2)}

=== POPE'S SYNTHESIS ===
${synthesis.summary}

Combined Attack Vector: ${synthesis.combinedAttackVector ?? 'N/A'}
Estimated Impact: $${synthesis.estimatedImpactUsd.toLocaleString()}
Confidence: ${(synthesis.confidence * 100).toFixed(1)}%

=== NOVEL INSIGHTS ===
${synthesis.novelInsights.map((i) => `- ${i}`).join('\n')}

=== TARGET CONTRACTS ===
${contractCode}

=== EXPLOIT TEMPLATES AVAILABLE ===
- ExploitBase: Basic exploit harness with common utilities
- FlashLoanBase: Flash loan template (Aave V3, Balancer, Uniswap V3)

Common addresses (Mainnet):
- AAVE_V3_POOL: 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2
- BALANCER_VAULT: 0xBA12222222228d8Ba445958a75a0704d566BF2C8
- WETH: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
- USDC: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48`;
  }

  /**
   * Generate exploit test harness
   */
  generateTestHarness(exploit: ForgedExploit): string {
    return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Exploit Test: ${exploit.vulnerability.title}
 * @notice Generated by The Vulnerability Swarm
 * @dev Vulnerability ID: ${exploit.vulnerability.id}
 *      Severity: ${exploit.vulnerability.severity}
 *      Confidence: ${(exploit.vulnerability.confidence * 100).toFixed(1)}%
 */
contract ExploitTest is Test {
    function setUp() public {
        // Fork mainnet at specific block for reproducibility
        vm.createSelectFork(vm.envString("ETH_RPC_URL"));
    }

    function testExploit() public {
        console.log("=== EXPLOIT: ${exploit.vulnerability.title} ===");
        console.log("Block:", block.number);

        uint256 initialBalance = address(this).balance;

        // Execute exploit
        _exploit();

        uint256 finalBalance = address(this).balance;
        int256 profit = int256(finalBalance) - int256(initialBalance);

        console.log("Initial Balance:", initialBalance);
        console.log("Final Balance:", finalBalance);
        console.log("Profit (wei):", profit > 0 ? uint256(profit) : 0);
        console.log("Profit (ETH):", profit > 0 ? uint256(profit) / 1e18 : 0);

        // Verify profit threshold
        require(profit >= ${this.config.profitThreshold} ether, "Exploit did not achieve minimum profit");
    }

    function _exploit() internal {
        // EXPLOIT CODE INSERTED HERE
${exploit.finalExploit.split('\n').map((l) => '        ' + l).join('\n')}
    }

    receive() external payable {}
}`;
  }

  /**
   * Get total usage across all forge agents
   */
  getTotalUsage(): { inputTokens: number; outputTokens: number; estimatedCost: number } {
    const agents = [this.directSmith, this.flashLoanSmith, this.chainedSmith, this.forgeMaster];
    return agents.reduce(
      (acc, agent) => {
        const usage = agent.getUsage();
        return {
          inputTokens: acc.inputTokens + usage.inputTokens,
          outputTokens: acc.outputTokens + usage.outputTokens,
          estimatedCost: acc.estimatedCost + usage.estimatedCost,
        };
      },
      { inputTokens: 0, outputTokens: 0, estimatedCost: 0 }
    );
  }
}

// ============================================================================
// Exports
// ============================================================================

export function createExploitForge(config?: Partial<ForgeConfig>): ExploitForge {
  return new ExploitForge(config);
}
