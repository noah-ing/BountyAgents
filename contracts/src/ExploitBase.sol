// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title ExploitBase
 * @notice Base contract for all exploit PoCs in The Vulnerability Swarm
 * @dev Provides common utilities for exploit development and testing
 */
abstract contract ExploitBase is Test {
    // ========================================================================
    // State
    // ========================================================================

    address public attacker;
    uint256 public attackerPrivateKey;

    uint256 public initialBalance;
    uint256 public finalBalance;

    // ========================================================================
    // Setup
    // ========================================================================

    function setUp() public virtual {
        // Create attacker with known private key for signing
        attackerPrivateKey = 0xA11CE;
        attacker = vm.addr(attackerPrivateKey);

        // Fund attacker with some ETH
        vm.deal(attacker, 100 ether);

        // Record initial balance
        initialBalance = attacker.balance;

        // Label for debugging
        vm.label(attacker, "Attacker");
    }

    // ========================================================================
    // Exploit Interface
    // ========================================================================

    /**
     * @notice Execute the exploit
     * @dev Override this in your exploit contract
     */
    function exploit() public virtual;

    /**
     * @notice Verify the exploit succeeded
     * @dev Should revert if exploit failed
     */
    function verify() public virtual {
        finalBalance = attacker.balance;

        // Default: check if we made profit
        int256 profit = int256(finalBalance) - int256(initialBalance);

        console.log("=== EXPLOIT RESULTS ===");
        console.log("Initial balance:", initialBalance / 1e18, "ETH");
        console.log("Final balance:", finalBalance / 1e18, "ETH");

        if (profit > 0) {
            console.log("Profit:", uint256(profit) / 1e18, "ETH");
            console.log("Status: SUCCESS");
        } else {
            console.log("Loss:", uint256(-profit) / 1e18, "ETH");
            console.log("Status: FAILED");
        }

        // Require minimum profit (0.1 ETH by default)
        require(profit >= 0.1 ether, "Exploit did not achieve minimum profit");
    }

    // ========================================================================
    // Test Runner
    // ========================================================================

    /**
     * @notice Main test function - runs exploit and verifies
     */
    function testExploit() public {
        console.log("=== STARTING EXPLOIT ===");
        console.log("Attacker:", attacker);
        console.log("Block:", block.number);
        console.log("Timestamp:", block.timestamp);
        console.log("");

        // Execute exploit as attacker
        vm.startPrank(attacker);
        exploit();
        vm.stopPrank();

        // Verify success
        verify();
    }

    // ========================================================================
    // Utilities
    // ========================================================================

    /**
     * @notice Get token balance
     */
    function getTokenBalance(address token, address account) internal view returns (uint256) {
        (bool success, bytes memory data) = token.staticcall(
            abi.encodeWithSignature("balanceOf(address)", account)
        );
        require(success, "balanceOf call failed");
        return abi.decode(data, (uint256));
    }

    /**
     * @notice Approve token spending
     */
    function approveToken(address token, address spender, uint256 amount) internal {
        (bool success,) = token.call(
            abi.encodeWithSignature("approve(address,uint256)", spender, amount)
        );
        require(success, "approve call failed");
    }

    /**
     * @notice Transfer tokens
     */
    function transferToken(address token, address to, uint256 amount) internal {
        (bool success,) = token.call(
            abi.encodeWithSignature("transfer(address,uint256)", to, amount)
        );
        require(success, "transfer call failed");
    }

    /**
     * @notice Log token balances
     */
    function logBalance(string memory label, address token, address account) internal view {
        uint256 balance = getTokenBalance(token, account);
        console.log(label, balance);
    }

    /**
     * @notice Fork mainnet at specific block
     */
    function forkMainnet(uint256 blockNumber) internal {
        string memory rpcUrl = vm.envString("ETH_RPC_URL");
        vm.createSelectFork(rpcUrl, blockNumber);
    }

    /**
     * @notice Fork mainnet at latest block
     */
    function forkMainnetLatest() internal {
        string memory rpcUrl = vm.envString("ETH_RPC_URL");
        vm.createSelectFork(rpcUrl);
    }

    /**
     * @notice Fork Arbitrum
     */
    function forkArbitrum(uint256 blockNumber) internal {
        string memory rpcUrl = vm.envString("ARBITRUM_RPC_URL");
        vm.createSelectFork(rpcUrl, blockNumber);
    }

    /**
     * @notice Impersonate an account
     */
    function impersonate(address target) internal {
        vm.startPrank(target);
    }

    /**
     * @notice Stop impersonating
     */
    function stopImpersonate() internal {
        vm.stopPrank();
    }

    /**
     * @notice Deal ETH to an address
     */
    function dealEth(address to, uint256 amount) internal {
        vm.deal(to, amount);
    }

    /**
     * @notice Deal ERC20 tokens (uses storage manipulation)
     */
    function dealToken(address token, address to, uint256 amount, uint256 balanceSlot) internal {
        bytes32 slot = keccak256(abi.encode(to, balanceSlot));
        vm.store(token, slot, bytes32(amount));
    }

    /**
     * @notice Warp time forward
     */
    function warpTime(uint256 secondsForward) internal {
        vm.warp(block.timestamp + secondsForward);
    }

    /**
     * @notice Roll blocks forward
     */
    function rollBlocks(uint256 blocksForward) internal {
        vm.roll(block.number + blocksForward);
    }

    // ========================================================================
    // Receive ETH
    // ========================================================================

    receive() external payable {}
    fallback() external payable {}
}
